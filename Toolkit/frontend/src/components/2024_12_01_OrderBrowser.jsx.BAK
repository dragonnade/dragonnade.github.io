import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import React, { useState, useEffect } from 'react';
import { ArrowUpDown, MessageSquare } from 'lucide-react';

const OrderBrowser = () => {
  console.log('OrderBrowser component rendering');
  const [orders, setOrders] = useState([]);
  const [selectedOrder, setSelectedOrder] = useState(null);
  const [selectedOrderName, setSelectedOrderName] = useState("");
  const [articles, setArticles] = useState([]);
  const [selectedArticle, setSelectedArticle] = useState(null);
  const [selectedArticleText, setSelectedArticleText] = useState("");
  const [similarities, setSimilarities] = useState([]);
  const [sortConfig, setSortConfig] = useState({ key: 'similarity', direction: 'desc' });
  const [filters, setFilters] = useState({
    category: '',
    minSimilarity: 0,
    minWordCount: 0,
    maxWordCount: Infinity
  });
  const [comments, setComments] = useState({});

  // Add logging to initial orders fetch
  const fetchOrders = async () => {
    console.log('Fetching orders...'); // Debug log
    try {
      const response = await fetch('http://localhost:3000/api/orders');
      if (!response.ok) throw new Error('Failed to fetch orders');
      const data = await response.json();
      console.log('Orders received:', data); // Debug log
      setOrders(data);
    } catch (error) {
      console.error('Error fetching orders:', error);
    }
  };

  const fetchArticles = async (orderId) => {
    try {
      console.log('Fetching articles for order:', orderId);
      const response = await fetch(`http://localhost:3000/api/articles/${orderId}`);
      if (!response.ok) throw new Error('Failed to fetch articles');
      const data = await response.json();
      console.log('Raw articles data:', data); // Debug log
      setArticles(data);
    } catch (error) {
      console.error('Error fetching articles:', error);
    }
  };

  


  useEffect(() => {
    fetchOrders();
  }, []);

  useEffect(() => {
    if (selectedOrder) {
      fetchArticles(selectedOrder);
      const orderData = orders.flatMap(y => y.orders).find(o => o.id === parseInt(selectedOrder));
      if (orderData) {
        setSelectedOrderName(orderData.name);
      }
    }
  }, [selectedOrder]);

  useEffect(() => {
    if (selectedArticle) {
      console.log('Attempting to fetch similarities'); // Debug log
      fetchSimilarities(selectedArticle);
    }
  }, [selectedArticle]);
  
  const fetchSimilarities = async (articleId) => {
    try {
      const response = await fetch(`http://localhost:3000/api/similarities/${articleId}`);
      if (!response.ok) throw new Error('Failed to fetch similarities');
      const data = await response.json();
      setSimilarities(data);
      console.log('Fetched similarities:', data); // Debug log
      console.log('Filtered and sorted similarities:', sortedSimilarities); // Debug log
    } catch (error) {
      console.error('Error fetching similarities:', error);
    }
  };

  const handleSort = (key) => {
    setSortConfig({
      key,
      direction: sortConfig.key === key && sortConfig.direction === 'desc' ? 'asc' : 'desc'
    });
  };

  const sortedSimilarities = similarities
    .filter(item => {
      return (
        (!filters.category || item.category === filters.category) &&
        (item.similarity >= filters.minSimilarity) &&
        (!filters.yearLimit || parseInt(item.year) >= new Date().getFullYear() - filters.yearLimit) &&
        (item.word_count >= filters.minWordCount) &&
        (item.word_count <= filters.maxWordCount)
      );
    })
    .sort((a, b) => {
      const direction = sortConfig.direction === 'desc' ? -1 : 1;
      if (sortConfig.key === 'similarity') {
        return direction * (a.similarity - b.similarity);
      }
      if (sortConfig.key === 'date') {
        return direction * (a.order_id - b.order_id);
      }
      return 0;
    });
  console.log('Filtered and sorted similarities:', sortedSimilarities); // Debug log
  const allOrders = orders.flatMap(yearGroup => yearGroup.orders);

  return (
    <div className="p-4 max-w-6xl mx-auto space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Order Browser</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="space-y-2">
            <label className="text-sm font-medium">Select Order</label>
            <Select onValueChange={setSelectedOrder} value={selectedOrder}>
              <SelectTrigger>
                <SelectValue placeholder="Select an order...">{selectedOrderName}</SelectValue>
              </SelectTrigger>
              <SelectContent className="max-h-[300px] overflow-y-auto">
                {allOrders.map(order => (
                  <SelectItem key={order.id} value={order.id.toString()}>
                    {order.name}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          {selectedOrder && (
            <div className="space-y-2">
              <label className="text-sm font-medium">Select Article</label>
              <div className="text-xs text-gray-500">{articles.length} articles loaded</div>
              <Select onValueChange={setSelectedArticle} value={selectedArticle}>
                <SelectTrigger>
                  <SelectValue placeholder="Select an article..." />
                </SelectTrigger>
                <SelectContent className="max-h-[300px] overflow-y-auto">
                  {articles.map(article => (
                    article && article.article_id ? (
                      <SelectItem 
                        key={article.article_id} 
                        value={article.article_id.toString()}
                      >
                        {`${article.article_number || 'No number'} - ${article.article_title || 'No title'}`}
                      </SelectItem>
                    ) : null
                  ))}
                </SelectContent>
              </Select>
            </div>
          )}

          {selectedArticle && similarities.length > 0 && (
            <div className="space-y-4">
              <div className="flex justify-between">
                <h3 className="text-lg font-semibold">Similar Articles ({similarities.length})</h3>
                <div className="space-x-2">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => handleSort('similarity')}
                  >
                    Similarity <ArrowUpDown className="ml-2 h-4 w-4" />
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => handleSort('date')}
                  >
                    Date <ArrowUpDown className="ml-2 h-4 w-4" />
                  </Button>
                </div>
              </div>

              <div className="space-y-4">
              {sortedSimilarities.map(item => (
                <Card key={item.similarity_id} className="p-4">
                  <div className="flex justify-between items-start">
                    <div>
                      <div className="font-medium">
                        {item.order_name} - Article {item.article_number}
                      </div>
                      <div className="text-sm text-gray-500">{item.article_title}</div>
                      <div className="mt-2 text-sm">{item.first_paragraph}</div>
                    </div>
                    <div className="text-right">
                      <div className="font-bold text-lg">
                        {(item.similarity).toFixed(2)}%
                      </div>
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => {
                          const newComments = { ...comments };
                          newComments[item.similarity_id] = newComments[item.similarity_id] || '';
                          setComments(newComments);
                        }}
                      >
                        <MessageSquare className="h-4 w-4" />
                      </Button>
                    </div>
                  </div>
                  {comments[item.similarity_id] !== undefined && (
                    <div className="mt-4">
                      <Input
                        value={comments[item.similarity_id]}
                        onChange={(e) => {
                          const newComments = { ...comments };
                          newComments[item.similarity_id] = e.target.value;
                          setComments(newComments);
                        }}
                        placeholder="Add a comment..."
                      />
                    </div>
                  )}
                </Card>
              ))}
              </div>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
};

export default OrderBrowser;